# Sprite介绍

*本介绍来自于官网，如想更详细的了解Sprite，请移步官网；https://www.pygame.org/docs/tut/SpriteIntro.html*

精灵模块来自于两个主要的类：

>## Sprite
 应作为所有游戏对象的基本类。它有几个函数来辅助管理游戏对象。

* 常用函数

1. ```add()```
   精灵将被添加到它还不是成员的组中。
    
    使用方法

    ```pygame.sprite.Sprite.add```

    注：其他精灵类函数使用方法类似，接下来不再赘述。

2. ```remove()``` 
   精灵将从它当前所在的组中移除。
   
3. ```kill()```
   精灵将从包含它的所有组中移除。这不会改变精灵的状态。可以在调用此方法之后继续使用Sprite，包括将其添加到组中。

4. ```alive()```
   当精灵属于一个或多个组时返回True。

5. ```groups()```
   返回包含此精灵的所有组的列表。

6. ```update()```
   此方法的默认实现不做任何事;它只是一个方便的“钩子”，您可以覆盖它。无论使用什么参数，Group.update()都会调用这个方法。
   
   **如果不使用Group类中同名的便利方法，则不需要使用此方法。**
   


>## Group
 是不同精灵的“集装箱”。其实是多个不同类型的组类，有些“Group”还可绘制出它包含的所有元素。

* 常用函数

1. ```sprites()``` 返回该组包含的所有精灵的列表。您还可以从组中获得迭代器，但是您不能在修改组时对其进行迭代。(我并不明白什么叫迭代器迭代什么的，我只是个莫的感情的搬运工)
   
   使用方法：

   ```pygame.sprite.Sprite.sprites()```

   注：其他组类函数使用方法类似，接下来不再赘述。


2. ```copy()``` 创建一个具有与原来相同精灵的新组。如果您已经子类化了组，那么新对象将具有与原始对象相同的(子)类。
   
   **这仅在派生类的构造函数与组类的构造函数参数相同时才有效。**

3. ```add()``` 向该组添加任意数量的精灵。这将只添加还不是该组成员的精灵。

4. ```remove()``` 从组中移除任意数量的精灵。这将只删除已经是组成员的精灵。

5. ```has()``` 如果组包含所有给定的精灵，则返回True。这类似于在组上使用“in”操作符(“if sprite in Group:…”)，它测试单个sprite是否属于一个组。

6. ```update()``` 在组中的所有精灵上调用update()方法。基本的Sprite类有一个更新方法，它接受任意数量的参数，但什么也不做。传递给Group.update()的参数将传递给每个精灵。
**无法从Sprite.update()方法获取返回值。**

7. ```draw()``` 将包含的精灵绘制到表面参数。这使用了Sprite.image属性为源表面，和Sprite.rect为位置。
**这个组没有保持精灵的任何顺序，所以绘制顺序是任意的。**

8. ```clear()``` 删除上一组Group.draw()调用的精灵，用背景填充绘制的精灵位置来清除目标表面。
   
   背景通常是与目标表面尺寸相同的表面图像，但它也可以是一个带两个参数的回调函数：目标表面和要清除的区域。后台回调函数将被调用多次，每次清除。

   下面是一个回调的例子，它将清除精灵与固体红色:
   ```python
   def clear_callback(surf, rect):
    color = 255, 0, 0
    surf.fill(color, rect)

    #说实在的，其实我没看懂
    ```
    
9. ```empty()``` 从该组中移除所有的精灵。



>## 同时使用Sprite和Group的优势
一个精灵可以属于任意多的组。记住，**只要它不属于任何组，它通常就会被清除**(除非您有其他“非组”对该对象的引用)。

1. 可以快速简单的将精灵分类。
   
   例如，假设我们有一个类似吃豆人的游戏。我们可以为游戏中不同类型的对象创建不同的组。幽灵，Pac和小球。当Pac吃掉一个异能球时，我们可以通过影响ghost组中的所有内容来改变ghost对象的状态。
   
   这比遍历所有游戏对象的列表并检查哪些对象是鬼更快更简单。
   
2. 相互添加和删除组和精灵是一种非常快的操作，比使用列表存储所有内容要快。
   因此，可以非常有效地更改组成员身份。组可以像每个游戏对象的简单属性一样工作。
   
   可以将它们添加到一个单独的组中，而不是跟踪一些敌对对象的属性，如“close_to_player”。当你需要访问玩家附近的所有敌人时，你已经有了一个敌人列表，而不是遍历所有敌人的列表，并检查“close_to_player”标志。之后你的游戏可以添加多个玩家，而不是添加更多的“close_to_player2”、“close_to_player3”属性，你可以轻松地将它们添加到不同的组或每个玩家。

3. 组可以干净地删除(或杀死)游戏对象。
 
   在一个许多对象都在引用其他对象的游戏中，有时候删除一个对象可能是最困难的部分，因为它在没有被任何人引用之前是不会消失的。
   
   假设我们有一个对象在“追逐”另一个对象。追逐者可以保持一个简单的组来引用它正在追逐的对象。如果被追逐的对象恰好被摧毁，我们不必担心通知追逐者停止追逐。追逐者可以看到自己的组现在是空的，并且可能会找到一个新的目标。
   
   同样，需要记住的是，从组中添加和删除精灵是一个非常便宜/快速的操作。**你最好添加许多组来包含和组织你的游戏对象**。有些甚至在游戏的大部分时间都是空的。



>## Sprite模块附带的组

上面的例子和使用精灵和群组的理由只是冰山一角,另一个优点是sprite模块附带了几个不同类型的组。这些组的工作方式与常规的旧组一样，但它们也添加了功能(或略有不同的功能)。下面是sprite模块中包含的组类列表。

1. ```Group```
   这是上面主要解释的标准的“无虚饰”组。其他大多数基团都来源于这个基团，但不是全部。

2. ```GroupSingle```
   它的工作原理与常规的Group类完全相同，但它只包含最近添加的sprite。因此，当你将一个精灵添加到这个组时，它将“忘记”它之前拥有的精灵。因此它总是只包含一个或0个精灵。

3. ```RenderPlain```
   这是由group派生出的一个标准组。它有一个draw()方法，该方法将它包含的所有精灵绘制到屏幕(或任何表面)。为了实现这一点，它要求它包含的所有精灵都具有“image”和“rect”属性。它利用这些信息来知道要做什么，在哪里做。

4. ```RenderClear```
   这是从RenderPlain组派生的，并添加了一个名为clear()的方法。这将删除所有绘制精灵的前一个位置。它使用背景图像来填充精灵所在的区域。当调用clear()方法时，处理已删除的精灵并正确地将它们从屏幕上清除是足够聪明的。

5. ```RenderUpdates```
   这是渲染组的凯迪拉克。它继承了RenderClear，但是改变了draw()方法来返回一个pygame Rects列表，它代表了屏幕上所有被改变的区域。